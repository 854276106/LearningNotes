# **C++**



## **引用返回左值**

* 函数的返回类型决定函数的调用是否可以为左值
* 若函数的返回类型为引用，则调用函数得到左值，返回其他类型得到右值
* 若函数的调用得到左值（返回引用），则可以像使用其他左值那样来使用该函数的调用
* 若函数的返回类型是非常量引用，可以为该函数返回的结果赋值

```c++
char &get_val(string &str,int ix)    //传递的参数是引用，返回值也是引用
{
    return str[ix];  //假定索引值有效
}

int main()
{
    string s("a value");
    cout<<s<<endl;  //输出 a value
    get_val(s,0)='A'; //将s[0]的值改为 A        返回非常量引用，可以对函数返回的结果赋值
    cout<<s<<endl;   //输出A value
    return  0;
}
```



## **内联函数**（inline）

### 特征

***

- 相当于把内联函数里面的内容写在调用内联函数处；
- 相当于不用执行进入函数的步骤，直接执行函数体；
- 相当于宏，却比宏多了类型检查，真正具有函数特性；
- 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；
- 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。

### 使用

***

*   C++ inline函数是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。
*  关键字 inline 必须与函数定义体放在一起才能使函数成为内联，仅将 inline 放在函数声明前面不起任何作用。 

```
// 声明1（加 inline）
inline int functionName(int first, int second,...);

// 声明2（不加 inline）
int functionName(int first, int second,...);

// 定义
inline int functionName(int first, int second,...) {/****/};

// 类内定义，隐式内联
class A {
    int doA() { return 0; }         // 隐式内联         在类中声明同时定义的成员函数，自动转化为内联函数
}

// 类外定义，需要显式内联
class A {
    int doA();
}
inline int A::doA() { return 0; }   // 需要显式内联
```

### 编译器对 inline 函数处理步骤

***

1. 将 inline 函数体复制到 inline 函数调用点处；
2. 为所用 inline 函数中的局部变量分配内存空间；
3. 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；
4. 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。

### 优缺点

------

优点

- 当函数体比较小的时候, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联. 
- 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。
- 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。
- 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。
- 内联函数在运行时可调试，而宏定义不可以。

缺点

*  滥用内联将导致程序变慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小.
*  现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。

结论

* 不要内联超过 10 行的函数
* 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!
* 内联那些包含循环或 switch 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 switch 语句从不被执行).
* 有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联. 
* 通常, 递归函数不应该声明成内联函数.(递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 
*  虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数. 



## mutable

* 可变数据成员：
  * 在申明变量时加入mutable关键字 (mutable int x;)
  * const成员函数也可以改变可变数据成员的值
  * 一个可变数据成员永远不会是const